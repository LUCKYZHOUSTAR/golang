package main

var ch3 chan int = make(chan int)

/**
其实，总结来看，为什么会死锁？非缓冲信道上如果发生了流入无流出，或者流出无流入，也就导致了死锁。或者这样理解 Go启动的所有goroutine里的非缓冲信道一定要一个线里存数据，一个线里取数据，要成对才行 。所以下面的示例一定死锁:
 */
func foo() {
	//fmt.Println("线程跑完了吗")
	//ch3 <- 3 // 向ch中加数据，如果没有其他goroutine来取走这个数据，那么挂起foo, 直到main函数把3这个数据拿走

}

func main() {
	go foo()
	//如果不用信道来阻塞主线的话，主线就会过早跑完，loop线都没有机会执行、、、
	/**
		如果只这样写的话，所有的goroutine都在等待等待信道的开放(没人拿走数据信道是不会开放的)，也就是死锁咯。
	*/
	//<-ch3 // 从ch取数据，如果ch中还没放数据，那就挂起main线，直到foo函数中放数据为止
	//fmt.Println(<-ch3)
	ch3<-6
}
